
 14강.
 14-1 ~ 14-2.



 # 2차원 배열.

2차원 배열 선언.
int s1[4] ; int s2[4] ; int s3[4] ;
int s[3][4] ;
s[0] = s1 ; s[1] = s2 ; s[2] = s3 ;

2차원 배열 특징.
모든 메모리 공간 주소가 연속되어 있다.
값을 사용할 때 s[0][0] , s[0][1] , ... s[1][0] , s[1][1] , ... s[n][n] 으로 표현된다.
scanf( "%d" , &s[0][0] ) 으로 2중 배열에 값을 입력받을 수 있다.

정수 2차원 배열의 초기화.
int s[3][4] = { { 값1-1, 값2-1, ... } , { 값2-1, 값2-2, ... } , { 값3-1, 값3-2, ... } } ;
int s[3][4] = { 1, 2, 3, ... } 이런식으로 중괄호를 생략할 수 있다.
int s[ ][4] = { ... } 처럼 선언과 동시에 초기화하면 개수를 생략할 수 있다.
행의 개수를 생략하면 초기화 값의 개수에 따라 행의 개수가 결정된다.
값을 넣지 않으면 0으로 초기화된다.

2차원 배열 개수 확인하기.
행의 개수 : sizeof( s ) / sizeof( s[0] ) ;
열의 개수 : sizeof( s[0] ) / sizeof( s[0][0] ) ;

문자 2차원 배열의 초기화.
char s[5][20] = { { 'a', 'b' , .. } , "dog" , ... } ;
문자 대입은 strcpy( s[0] , "abc" ) 와 같이 대입해야된다. 

3차원 배열.
면, 행, 열을 가지고 있다.
2차원 배열을 여러개 저장할 때 사용한다.
입출력 할 때 3중 for문을 사용해야된다.



 # 포인터 배열.

포인터 배열.
char * p[ 5 ] ; 
주소 저장하는 4byte의 메모리 공간이 5개 생성된다.
p[0] = "String" 를 저장할 수 있다.

포인터 배열 초기화.
char * p[ 5 ] = { "Hello" , "World" ,  ... }

포인터 배열의 필요성.
1차원 배열의 주소를 포인터 배열에 저장해서 2차원 배열처럼 사용할 수 있게 해준다.
1차원 배열의 주소값을 활용하기 때문에 1차원 배열의 길이가 같을 필요 없다.




